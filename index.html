<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Clojure in the Service of Her Majesty's Government</title>
    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="lib/css/zenburn.css">
</head>

<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h1>Clojure in the Service of Her Majesty's Government</h1>
            <h2>Rachel Newstead</h2>
            <h2>Philip Potter</h2>
            <h2><a href="http://philandstuff.github.io/clojure-hmg/">http://philandstuff.github.io/clojure-hmg/</a></h2>
        </section>
        <section data-background="services.png"></section>
        <section>
          <section data-background="register-a-wand.png"></section>
          <section data-background="verify-start.png"></section>
          <section data-background="verify-choose-idp.png"></section>
          <section data-background="digidentity.png"></section>
        </section>
        <section>
          <aside class="notes">
            Benefits:
            <ul>
              <li>single set of credentials for all of government
              <li>services don't have to reinvent the wheel
              <li>separation of data -- services don't get access unless you log in to them
            </ul>
          </aside>
        </section>
        <section>
          <aside class="notes">
            Here are the what ifs:

            Suppose I'm a manager of a Quidditch Club.  We need to buy
            some wands for the squad.

            <ul>
              <li>Register to club and not to individual
              <li>How does the ministry know we're a real club?
              <li>How does the ministry know I'm really the manager?
            </ul>
          </aside>
        </section>
        <section>
          <section>
            <h1>Identity Assurance for Organisations and Agents</h1>
            <h1>Alpha</h1>
          </section>
          <section data-background="phases.png"></section>
          <section>
            <h1>Can we build something that people would want to use?</h1>
          </section>
          <section>
            <h1>The team</h1>
            <aside class="notes">the team</aside>
          </section>
          <section>
            <h1>GOV.UK Verify technology</h1>
            <ul>
              <li>Java</li>
              <li>DropWizard</li>
              <li>SAML</li>
            </ul>
          </section>
          <section>
            <h1>Technology to explore</h1>
            <ul>
              <li>Clojure</li>
              <li>OpenID Connect</li>
            </ul>
          </section>
        </section>
        <section>
          <section><img src="simple-auth.png"></section>
          <section><img src="auth-with-hub.png"></section>
          <section><img src="auth-with-hub-no-ua.png"></section>
        </section>
        <section>
          <h1>Technical questions</h1>
          <h2>What would the architecture look like?</h2>
          <h2>How many components are there?</h2>
          <h2>How are responsibilities split?</h2>
          <aside class="notes">
            Architectural questions to answer
          </aside>
        </section>
        <section>
            <h2>how did we convince the those in charge to let us use clojure?</h2>
            <p>it was made easier as we were building a prototype that was intended to be thrown away</p>
        </section>

        <section>
            <section>
                <h2>how was it using clojure for the first time?</h2>
                <h3>for someone who had never used it before?</h3>
                <aside>
                    <ul>
                        <li>Background - java, some scala, racket</li>
                        <li>no time to learn clojure first</li>
                        <li>found it easy to pick up</li>
                        <li>concise and simple</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h1><pre><code class="clojure" data-trim>
(defn say-hello [request]
    (let [name (get-in request [:query-params "name"])]
                (build-html name))

(defn app-routes [config]
    (handler/site
        (routes ( GET "/hello-world" [:as request]
                    (say-hello request)))))
                </code></pre></h1>
                <aside>
                    <ul>
                        <li>http request and response are maps, so once you know what you can do with a map</li>
                        <li>not much code</li>
                        <li>easy to read, debug</li>
                        <li>very different to scala</li>
                        <li>in clojure extra features are put into different libraries</li>
                        <li>with their own docs</li>
                        <li>in scala everything is put into the language</li>
                        <li>this confuses me</li>
                        <li>means there are many different ways to do things</li>
                    </ul>
                </aside>
            </section>
            <section data-background="clojure-cheatsheet.png">
                <aside>
                    <ul>
                        <li>clojure cheatsheet</li>
                        <li>would keep this open when working</li>
                        <li>shows how concise the language is</li>
                        <li>repl v.useful</li>
                        <li>jay fields - repl driven development</li>
                        <li>is my app doing what i expect?</li>
                        <li>what happens when i execute this arbitrary code?</li>
                        <li>initially this second point helped me work out how to use the language</li>
                        <li>quicker feedback than unit test</li>
                        <li>and for that sort of thing you would end up deleting the test anyway</li>
                    </ul>
                </aside>
            </section>
            <section><img src="real-programmers.png">
                <aside>
                    <ul>
                        <li>why did we use emacs?</li>
                        <li>easier to use the same ide when you're pairing</li>
                        <li>for a short project, felt like it would be cheaper to deal with everyone learning one ide</li>
                        <li>rather than each picking their favourite!</li>
                        <li>evil mode helped our vi user</li>
                        <li>although made pairing trickier!</li>
                        <li>not too bad to start with</li>
                        <li>if you don't know the language it doesn't matter if you don't know the shortcuts!</li>
                        <li>missed having an ide for small refactors and renames</li>
                        <li>still struggled with emacs by the end</li>
                        <li>by halfway felt like it wasn't actively blocking me getting things done</li>
                        <li>but also didn't feel like it was helping</li>
                        <li>i think if you want to get moving quickly with clojure, emacs at the same time maybe isn't the win</li>
                        <li>apparently cursive plugin for intellij is good</li>
                    </ul>
                </aside>
            </section>
            <section data-background="emacs-cheatsheet.png">
                <aside>
                    <ul>
                        <li>if you are going to use emacs...</li>
                        <li>there are many cheatsheets</li>
                        <li>these are much more complicated than the clojure cheatsheets!</li>
                        <li>emacs live was initially good</li>
                        <li>but the shortcuts were different</li>
                        <li>and it didn't play that well with midje tests</li>
                        <li>magit is awesome</li>
                        <li>sometimes i still use this for complex git merges</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h2>how was it using clojure for the first time?</h2>
                <h3>for a keen hobbyist?</h3>
            </section>
        </section>

        <section>
            <section>
                <h2>what worked?</h2>
            </section>
            <section>
                <h1>reloaded workflow</h1>
                <aside>
                    <ul>
                        <li>Cider = clojure repl and ide for emacs</li>
                        <li>built on nrepl</li>
                        <li>lets you connect to a running app</li>
                        <li>and dynamically redefine parts of it</li>
                        <li>used stuart sierra's reloaded flow</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h1>
                <pre><code class="clojure" data-trim>
(defonce candela nil)

(defn go []
        (alter-var-root #'candela
        (constantly (jetty/run-jetty (cweb/app config)))))

(defn stop []
    (.stop candela))

(defn reset []
    (stop)
    (repl/refresh :after 'user/go))
                </code></pre></h1>
                <aside>
                    <ul>
                        <li>uses clojure.tools.namespace to work out which source files have changed</li>
                        <li>refreshes these in the running dev env</li>
                        <li>you have to define the reset function in user.clj</li>
                        <li>loaded by default when you start the repl</li>
                        <li>stops the running app</li>
                        <li>reloads changed namespaces</li>
                        <li>creates and starts the app again</li>
                        <li>all within the same jvm</li>
                        <li>so super fast</li>
                        <li>which means super fast feedback - just call reset from repl</li>
                        <li>have to define a dev profile in your leingingen config</li>
                        <li>so the user.clj file is only used in dev</li>
                        <li>not deployed in the jar</li>
                        <li>this dramatically improved our dev experience</li>
                        <li>took us a while to get it working</li>
                        <li>you have to have no global state - so you can stop and start up without problems</li>
                        <li>and have to pass things that might otherwise be global, e.g. db connections, thread pool as params</li>
                        <li>didn't work so well with the frontend stuff</li>
                        <li>used enlive for templating</li>
                        <li>when html files changed on disk this was not picked up</li>
                        <li>will talk more about this later</li>
                    </ul>
                </aside>
            </section>
            <section>
                <h1>kerodon</h1>
            </section>
            <section>
                <h1><pre><code class="clojure" data-trim>
(-> (session ring-app)
  (visit "/")
  (follow "login")
  (fill-in "User:" "username")
  (fill-in "Password:" "password")
  (press "Login")
  (follow-redirect)
  (has (missing? [:#no-such-element])
       "User shouldn't see the no-such-element"))
                </code></pre></h1>
            </section>
            <section>
                <h1><pre><code class="clojure" data-trim>
(-> (ida-session (combined-handler)
  (visit "http://wands.gov.uk/register")
  (helpers/sign-in)
  (follow "Delegate your authority")
  (visit "http://wands.gov.uk/persist-delegation"
         :request-method :post)
  (follow-redirect) ; to Identity Provider
  (press "Continue")
  (follow-redirect) ; back to service
  (check-response
    (should-redirect-to
      "http://wands.gov.uk/"))))
                </code></pre></h1>
            </section>
            <section>
              <img src="ring-handler.png">
            </section>
            <section>

              <h1><pre><code class="clojure" data-trim>
(defn combined-handler []
  (let [apps {"idp.com"       michie/handler
              "orch.gov.uk"   knox/handler
              "wands.gov.uk"  candela/handler
              "orgs.gov.uk"   al-kindi/handler
              "agents.gov.uk" wheatstone/handler}]
    (fn [req]
      (let [app (get apps (:server-name req)
                     default-handler)]
        (app req)))))
                </code></pre></h1>

            </section>
            <section>
                <h1>adding orchestration</h1>
            </section>
            <section>
                <section><img src="simple-auth-no-ua.png"></section>
            </section>
            <section>
                <section><img src="auth-with-hub-no-ua.png"></section>
                <aside>
                    <h2>Advantages</h2>
                    <ul>
                        <li>work with multiple services</li>
                        <li>work with multiple idps</li>
                        <li>only need to change the hub in the middle</li>
                        <li>layer of privacy in the middle</li>
                        <li>the service doesn't need to know which idp is being used</li>
                        <li>idp doesn't need to know which service is being used</li>
                        <li>how gov uk verify works</li>
                        <li>hub doesn't store any data</li>
                        <li>just passes data around</li>
                        <li>with ring and compojure easy to add a new web service</li>
                        <li>http req and resp just maps</li>
                        <li>to the service the hub looks like an idp</li>
                        <li>to the idp the hub looks like a service</li>
                    </ul>
                </aside>
            </section>
        </section>

        <section>
            <h2>what didn't go so well?</h2>
        </section>

        <section>
            <h2>was it a success?</h2>
            <aside>
                <ul>
                    <li>Achieved technical aim</li>
                    <li>didn't implement everything</li>
                    <li>good understanding of how the system could work</li>
                    <li>different options of how it could be built</li>
                    <li>could see what would require further technical exploration</li>
                    <li>kerodon tests expressive enough to be part of the technical artifact of the alpha</li>
                    <li>not perfect code but that wasn't the aim</li>
                </ul>
            </aside>
        </section>
        <section>
            <section>
                <h2>what is happening now?</h2>
            </section>
            <section>
                <blockquote cite="https://www.gov.uk/service-manual/phases/ideal-alphas#ending-the-alpha">
                    &ldquo;Remember that a primary goal during the alpha is learning.
                    We might not be ready to make the investment in creating production-ready systems.
                    In particular, that investment might be premature if the team learns they are not solving the right problem.&rdquo;
                </blockquote>
                <aside>
                    <ul>
                        <li>needs for org ida not the same across services</li>
                        <li>doesn't make sense for gds to build a govt wide thing</li>
                        <li>some services need fine grained perms, others don't</li>
                        <li>some services already have relationships established</li>
                        <li>if you’re the headmaster of hogwarts and have been registering
                            wands for ten years with the ministry of magic you don't want
                            to suddenly prove that you have the authority to do so</li>
                        <li>already commercial solutions available</li>
                        <li>see ida blog for more info</li>
                    </ul>
                </aside>
            </section>
        </section>

        <section>
            <h2>would we use clojure for a similar project?</h2>
            <aside>
                <ul>
                    <li>With a similar team, yes</li>
                    <li>probably even if the team had no experience in clojure</li>
                    <li>it is quick to pick up</li>
                    <li>this has shown it's good for prototyping</li>
                    <li>good precedent set at gds</li>
                    <li>Other TW prototypes have since been built in clojure</li>
                </ul>
            </aside>
        </section>

    </div>

</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>

<script>
    Reveal.initialize({
    history: true,
    margin: 0.00,
    // Optional libraries used to extend on reveal.js
dependencies: [
        // Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
        { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },

        // Interpret Markdown in <section> elements
        //{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        //{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

        // Syntax highlight for <code> elements
        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

        // Zoom in and out with Alt+click
        { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },

        // Speaker notes
        { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },

        // Remote control your reveal.js presentation using a touch device
        //{ src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } },

        // MathJax
        { src: 'plugin/math/math.js', async: true }
    ]
    });

</script>

</body>
</html>
